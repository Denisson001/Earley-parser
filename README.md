# Earley-parser

## Usage example

- Собрать проект (директория **`src`**)

```
g++ -std=c++11 main.cpp solver.cpp earley_parser.cpp -o main
```

- Собрать и запустить тесты (директория **`tests`**)

```
g++ -std=c++11 tests.cpp ../src/solver.cpp ../src/earley_parser.cpp -o tests
./tests
```

# TODO : 

## Project

- Директория **`src`**:
  - **`main`** - точка входа.
  - **`solver`** - реализация алгоритма.
  - **`data`** - формат входных данных.

- Директория **`tests`**:
  - **`tests.cfg`** - конфиг тестов.
  - **`tests.cpp`** - запуск тестов. 
  - **`sample`** - тесты из задания. 
  - **`base`** - мои тесты.
  - **`description.md`** - описание тестов.

## Algo

- В исходниках есть комментарии к коду.
- Итеративно обрабатываем регулярное выражение. 
Обозначим длину слова, максимальный префикс которого ищем, за `n`.
- Для промежуточных подвыражений храним двумерную булеву матрицу динамического программирования на стеке.
- Позиция `i, j` в матрице true тогда и только тогда, когда в языке, задаваемом этим подвыражением, 
лежит подслово `[i, j)` исходного слова.
- Разбор случаев по символам в регулярном выражении:
  - `+` - Достаточно сделать поэлементное логическое "или" матриц. Временная сложность `O(n^2)`.
  - `.` - Для каждого подинтервала перебираем позицию внутри интервала. 
  Для каждого такого разделения подинтервала на два проверяем, 
  лежит ли первое подслово в языке первого подвыражения, а второе - во втором. Временная сложность `O(n^3)`.
  - `*` - Перебираем подинтервалы в порядке увеличения длины.
  Для каждого подинтервала перебираем суффикс, который должен лежать в языке подвыражения. 
  Для префикса подинтервала уже знаем, лежит ли он в языке, полученном применением звезды Клини.
  Временная сложность `O(n^2)`.
  - `a, b, c` - Для каждого интервала вида `[i, i + 1)` проверим, что соответствующие буквы совпадают. 
  Временная сложность `O(n^2)`.
  - `1` - Для каждого интервала вида `[i, i)` проставляем `true`. Временная сложность `O(n^2)`.
- Проверяем, что в любой момент работы алгоритма, на стеке лежит достаточное количество элементов. 
А в конце работы алгоритма на стеке лежит ровно один элемент.
- По значению динамического программирования в этом элементе находим ответ на задачу.
- Итоговая временная сложность алгоритма `O(n^3)`, принимая длину регулярного выражения за константу. 
