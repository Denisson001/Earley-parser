# Earley-parser

## Usage example

- Собрать проект (директория **`src`**)

```
g++ -std=c++11 main.cpp solver.cpp earley_parser.cpp state.cpp -o main
```

- Собрать и запустить тесты (директория **`tests`**)

```
g++ -std=c++11 tests.cpp ../src/solver.cpp ../src/earley_parser.cpp ../src/state.cpp -o tests
./tests
```

# TODO : 

## Project

- Директория **`src`**:
  - **`main`** - точка входа.
  - **`earley_parser`** - реализация алгоритма.
  - **`solver`** - работы с вводом, запуск решения.
  - **`rule`, `state`** - описание внешних структур.

- Директория **`tests`**:
  - **`tests.cfg`** - конфиг тестов.
  - **`tests.cpp`** - запуск тестов. 
  - **`base`** - тесты.
  - **`description.md`** - описание тестов.

## Algo

- В исходниках есть комментарии к коду.
- Пример формата ввода можно посмотреть в тестах 
- **Временная сложность** алгоритма:
  - Обозначим за `|w|` длину слова, принадлежность языку которого проверяет алгоритм  
  - Размер грамматики будем считать константой, обозначим ее за `|G|`
  - Количество множеств состояний `|w| + 1 = O(|w|)`
  - Количество состояний в одном множестве состояний - `|G| * |w| = O(|w|)`
  - Цикл но номеру множества состояний делает `|w|` итераций
    - На каждой итерации один раз вызывается **`scan`**, который пробегается по всем состояниям в множестве и делает `O(1)` действий. Суммарная сложность всех вызовов `scan` есть `|w|^2 * |G| = O(|w|^2)`. 
    - Для одного множества состояний функция **`predict`** вызывается на каждое изменение множества, т.е. `O(|w|)` раз. Функция смотрит на все состояния в множестве и для каждого делает релаксацию за размер грамматики. За счет запоминания, каждое состояние вызовет релаксацию ровно один раз. Итоговая сложность всех вызовов `predict` есть `|w|^2 * |G|^2 = O(|w|^2)`
    - Для одного множества состояний функция **`complete`** вызывается на каждое изменение множества, т.е. `O(|w|)` раз. Функция смотрит на все состояния в множестве и для каждого делает релаксацию за размер некоторого другого множества состояний, размер которого есть `O(|w|)`. На каждый вызов `complete` будут просматриваться все состояния в множестве, но релаксация для одного состояния за счет запоминания суммарно будет выполняться за `O(|w|)`. Итоговая сложность всех вызовов `complete` есть `|w| * |G|^2 * (|w|^2 + |w|^2) = O(|w|^3)`.
- **Затраты памяти**
  - Затраты по памяти на массивы `_states_array`, `_used_states` есть `O(|w|^2)`.